<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
<meta name="pinterest" content="nopin">
<meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1">
<meta name="generator" content="Hugo 0.20.6" />



<link rel="canonical" href="https://agchen28.github.io/blog/%E5%AE%A2%E6%88%B7-%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A8%A1%E5%9E%8B/">


    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet">
    <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/styles/solarized_dark.min.css">
    <title>客户-服务器模型 - agchen</title>
    
<meta name="description" content="大部分网络应用程序在编写时都假设一端是客户，另一端是服务器，其目的是让服务器为客户提供特定服务。一般将这种服务分为两种类型：重复型或并发型。 重复型：重复型服务器通过以下步骤进行交互：1.等待一个客户请求的到来2.处理客户请求3.发送响应给客户4.返回1步重复型服务器的主要问题发生在2步，这时候它不能为其他客户提供服务。 这种执行模型是同步的，它同时只能处理一个请求，其他的请求都必须按次序等待服务。这种服务模型处理能力相当低下，假设处理每个请求消耗的时间为N秒，这类服务的QPS就为1/N。 并发型：并发型服务器采用以下步骤：1.等待一个客户请求的到来2.启动一个新的服务器来处理客户的请求。可能生成一个新的进程、线程或者任务，并依赖底层操作系统的支持。生成新的服务器对用户的全部请求进行处理，处理结束后终止这个服务器。3.返回1  并发型服务器的实现方式 每请求每进程 为每一个请求都单独创建一个进程来作为服务。这种模型的缺点就是代价非常大，内存占用高，进程的创建与销毁时间开销大，而且每台机器所能创建的进程也非常有限。每请求每线程 由于创建进程开销过大，所以引入了多线程模型。线程相对于进程来说开销小很多，而且进程之间的每个线程可以共享数据。每个线程都有一个独立的线程栈，需要占用一定的内存空间。当并发量非常大的时候，会同时创建大量的线程，这样内存占用就上来了。而且还会出现另外一个问题，就是CPU上下文频繁切换的开销。 每个CPU核心在同一时刻只能处理一件事，操作系统通过将CPU切分时间片的方法，让线程可以较为均匀地使用CPU资源。当线程数量过多的时候，进行上下文切换的消耗就会变大。这种模型应用的非常广泛，常见的ASP.NET或者Java编写的网络服务一般都属于这种模型。这类服务可以采用异步I/O的方式来提升服务器性能。不得不提一下C#的异步编程，它提供的一些语法糖写起来就跟写同步代码差不多，简直太傻瓜化、太爽了。事件驱动 事件驱动这四个字不是很好理解。我把它理解为是为了实现异步I/O的一种处理方式：当执行I/O操作时，绑定一个事件，等I/O操作完成会触发这个事件。（I/O操作包括读写数据库，读写文件，网络请求等一些除CPU计算之外的操作）采用这种实现方式的有Node和Nginx，利用单线程来避免高并发下内存开销大和上下文切换频繁的问题。不过它是如何利用单线程就能处理大量的请求呢？以Node为例来解释一下这个问题。考虑到目前的网络服务处理的大部分请求都是跟I/O操作相关，而且I/O操作在整个响应过程中一般是最耗时的。如果采用以往同步I/O的方式，就会阻塞这个线程，必须等I/O操作完才能执行接下来的任务。Node的特点包括单线程和异步I/O。其实在单线程的条件下，真正并发执行的是I/O操作。每个请求按次序等待该线程的处理，不过由于异步I/O的特点，每个请求进来触发I/O操作，即使I/O操作还没执行完，该线程也能继续处理其他请求。这类服务有个特点就是不处理或者只处理非常少量的CPU计算（这也可以说是它的缺点）。假设有一个极端的场景：每个请求都不需要I/O操作，但是都需要比较耗时的CPU计算。那么这类服务就会表现得跟重复型服务一样，每个请求都会阻塞服务。虽然Node可以为每个耗时的CPU计算创建一个子进程，如果为每个请求都创建一个进程就会表现得跟每请求每进程一样。当然这种场景现实中应该不会出现，举这个例子主要还是为了说明它的特点。Goroutine 这是之前瞎捣鼓Go的时候接触到的东西。Go的出现是为了解决在21世纪多核和网络化环境下越来越复杂的编程问题。可能大部分技术人员对Google都会有迷之信仰，谷歌出品，必属精品。Go的并发模型理论指导来自于贝尔实验室的Tony Hoare于1978年发表的鲜为外界所知的关于并发研究的基础文献顺序通信进程 （communicating sequential processes） ，缩写为CSP。（看来什么事情都是理论先行啊，就如当年的XX主义。）在CSP中，程序是一组中间没有共享状态的平行运行的处理过程，它们之间使用管道进行通信和控制同步。在这样的理论指导下，Go采用Goroutine来实现并行，Goroutine之间通过Channels来通信，而不提倡使用共享数据和锁。我们可以借助线程来理解Goroutine。每个线程都会分配到一定大小的内存（一般为2M）作为线程栈，这个栈用来存储当前正在调用或者被挂起的函数的内部变量。如果采用每请求每线程的服务，可能大部分的请求都用不了多少的栈空间，这就造成内存的浪费。每个Goroutine会分配到一个动态栈，一开始为2KB（应用到网络服务，这可能已经能满足大部分请求所需要的栈空间了）。栈的大小会根据需要动态伸缩，最大可达1GB，虽然一般用不到这么大，但是对于更复杂，更深层次的函数递归调用，可能会需要大一点的栈空间。由于创建Goroutine的成本非常低，所以创建成百上千Goroutine是非常普遍的。利用Goroutine来处理请求，既能保证资源充分利用，又不会因为执行CPU计算而阻塞服务。关键地方在于Go的运行时包含一个调度器（它决定了Goroutine调度的效率）。它采用m:n调度，表示会在n个操作系统线程上调度m个Goroutine。n通过GOMAXPROCS这个变量来决定，默认为CPU核心数。就个人愚见，Go的并发模型真的是非常棒，既能保证资源充分利用，又不会因为执行CPU计算而阻塞服务。事件驱动模型虽然能处理很大的并发请求，但是有其局限性。多线程模型目前的问题主要是同步I/O操作长时间阻塞线程，导致创建大量的线程，如果采用异步I/O的方式相信性能方面会提升很多。">

<meta property="og:title" content="客户-服务器模型 - agchen">
<meta property="og:type" content="article">
<meta property="og:url" content="https://agchen28.github.io/blog/%E5%AE%A2%E6%88%B7-%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A8%A1%E5%9E%8B/">
<meta property="og:image" content="https://agchen28.github.io/images/default.png">
<meta property="og:site_name" content="agchen">
<meta property="og:description" content="大部分网络应用程序在编写时都假设一端是客户，另一端是服务器，其目的是让服务器为客户提供特定服务。一般将这种服务分为两种类型：重复型或并发型。 重复型：重复型服务器通过以下步骤进行交互：1.等待一个客户请求的到来2.处理客户请求3.发送响应给客户4.返回1步重复型服务器的主要问题发生在2步，这时候它不能为其他客户提供服务。 这种执行模型是同步的，它同时只能处理一个请求，其他的请求都必须按次序等待服务。这种服务模型处理能力相当低下，假设处理每个请求消耗的时间为N秒，这类服务的QPS就为1/N。 并发型：并发型服务器采用以下步骤：1.等待一个客户请求的到来2.启动一个新的服务器来处理客户的请求。可能生成一个新的进程、线程或者任务，并依赖底层操作系统的支持。生成新的服务器对用户的全部请求进行处理，处理结束后终止这个服务器。3.返回1  并发型服务器的实现方式 每请求每进程 为每一个请求都单独创建一个进程来作为服务。这种模型的缺点就是代价非常大，内存占用高，进程的创建与销毁时间开销大，而且每台机器所能创建的进程也非常有限。每请求每线程 由于创建进程开销过大，所以引入了多线程模型。线程相对于进程来说开销小很多，而且进程之间的每个线程可以共享数据。每个线程都有一个独立的线程栈，需要占用一定的内存空间。当并发量非常大的时候，会同时创建大量的线程，这样内存占用就上来了。而且还会出现另外一个问题，就是CPU上下文频繁切换的开销。 每个CPU核心在同一时刻只能处理一件事，操作系统通过将CPU切分时间片的方法，让线程可以较为均匀地使用CPU资源。当线程数量过多的时候，进行上下文切换的消耗就会变大。这种模型应用的非常广泛，常见的ASP.NET或者Java编写的网络服务一般都属于这种模型。这类服务可以采用异步I/O的方式来提升服务器性能。不得不提一下C#的异步编程，它提供的一些语法糖写起来就跟写同步代码差不多，简直太傻瓜化、太爽了。事件驱动 事件驱动这四个字不是很好理解。我把它理解为是为了实现异步I/O的一种处理方式：当执行I/O操作时，绑定一个事件，等I/O操作完成会触发这个事件。（I/O操作包括读写数据库，读写文件，网络请求等一些除CPU计算之外的操作）采用这种实现方式的有Node和Nginx，利用单线程来避免高并发下内存开销大和上下文切换频繁的问题。不过它是如何利用单线程就能处理大量的请求呢？以Node为例来解释一下这个问题。考虑到目前的网络服务处理的大部分请求都是跟I/O操作相关，而且I/O操作在整个响应过程中一般是最耗时的。如果采用以往同步I/O的方式，就会阻塞这个线程，必须等I/O操作完才能执行接下来的任务。Node的特点包括单线程和异步I/O。其实在单线程的条件下，真正并发执行的是I/O操作。每个请求按次序等待该线程的处理，不过由于异步I/O的特点，每个请求进来触发I/O操作，即使I/O操作还没执行完，该线程也能继续处理其他请求。这类服务有个特点就是不处理或者只处理非常少量的CPU计算（这也可以说是它的缺点）。假设有一个极端的场景：每个请求都不需要I/O操作，但是都需要比较耗时的CPU计算。那么这类服务就会表现得跟重复型服务一样，每个请求都会阻塞服务。虽然Node可以为每个耗时的CPU计算创建一个子进程，如果为每个请求都创建一个进程就会表现得跟每请求每进程一样。当然这种场景现实中应该不会出现，举这个例子主要还是为了说明它的特点。Goroutine 这是之前瞎捣鼓Go的时候接触到的东西。Go的出现是为了解决在21世纪多核和网络化环境下越来越复杂的编程问题。可能大部分技术人员对Google都会有迷之信仰，谷歌出品，必属精品。Go的并发模型理论指导来自于贝尔实验室的Tony Hoare于1978年发表的鲜为外界所知的关于并发研究的基础文献顺序通信进程 （communicating sequential processes） ，缩写为CSP。（看来什么事情都是理论先行啊，就如当年的XX主义。）在CSP中，程序是一组中间没有共享状态的平行运行的处理过程，它们之间使用管道进行通信和控制同步。在这样的理论指导下，Go采用Goroutine来实现并行，Goroutine之间通过Channels来通信，而不提倡使用共享数据和锁。我们可以借助线程来理解Goroutine。每个线程都会分配到一定大小的内存（一般为2M）作为线程栈，这个栈用来存储当前正在调用或者被挂起的函数的内部变量。如果采用每请求每线程的服务，可能大部分的请求都用不了多少的栈空间，这就造成内存的浪费。每个Goroutine会分配到一个动态栈，一开始为2KB（应用到网络服务，这可能已经能满足大部分请求所需要的栈空间了）。栈的大小会根据需要动态伸缩，最大可达1GB，虽然一般用不到这么大，但是对于更复杂，更深层次的函数递归调用，可能会需要大一点的栈空间。由于创建Goroutine的成本非常低，所以创建成百上千Goroutine是非常普遍的。利用Goroutine来处理请求，既能保证资源充分利用，又不会因为执行CPU计算而阻塞服务。关键地方在于Go的运行时包含一个调度器（它决定了Goroutine调度的效率）。它采用m:n调度，表示会在n个操作系统线程上调度m个Goroutine。n通过GOMAXPROCS这个变量来决定，默认为CPU核心数。就个人愚见，Go的并发模型真的是非常棒，既能保证资源充分利用，又不会因为执行CPU计算而阻塞服务。事件驱动模型虽然能处理很大的并发请求，但是有其局限性。多线程模型目前的问题主要是同步I/O操作长时间阻塞线程，导致创建大量的线程，如果采用异步I/O的方式相信性能方面会提升很多。">
<meta property="og:locale" content="ja_JP">

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="agchen">
<meta name="twitter:url" content="https://agchen28.github.io/blog/%E5%AE%A2%E6%88%B7-%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A8%A1%E5%9E%8B/">
<meta name="twitter:title" content="客户-服务器模型 - agchen">
<meta name="twitter:description" content="大部分网络应用程序在编写时都假设一端是客户，另一端是服务器，其目的是让服务器为客户提供特定服务。一般将这种服务分为两种类型：重复型或并发型。 重复型：重复型服务器通过以下步骤进行交互：1.等待一个客户请求的到来2.处理客户请求3.发送响应给客户4.返回1步重复型服务器的主要问题发生在2步，这时候它不能为其他客户提供服务。 这种执行模型是同步的，它同时只能处理一个请求，其他的请求都必须按次序等待服务。这种服务模型处理能力相当低下，假设处理每个请求消耗的时间为N秒，这类服务的QPS就为1/N。 并发型：并发型服务器采用以下步骤：1.等待一个客户请求的到来2.启动一个新的服务器来处理客户的请求。可能生成一个新的进程、线程或者任务，并依赖底层操作系统的支持。生成新的服务器对用户的全部请求进行处理，处理结束后终止这个服务器。3.返回1  并发型服务器的实现方式 每请求每进程 为每一个请求都单独创建一个进程来作为服务。这种模型的缺点就是代价非常大，内存占用高，进程的创建与销毁时间开销大，而且每台机器所能创建的进程也非常有限。每请求每线程 由于创建进程开销过大，所以引入了多线程模型。线程相对于进程来说开销小很多，而且进程之间的每个线程可以共享数据。每个线程都有一个独立的线程栈，需要占用一定的内存空间。当并发量非常大的时候，会同时创建大量的线程，这样内存占用就上来了。而且还会出现另外一个问题，就是CPU上下文频繁切换的开销。 每个CPU核心在同一时刻只能处理一件事，操作系统通过将CPU切分时间片的方法，让线程可以较为均匀地使用CPU资源。当线程数量过多的时候，进行上下文切换的消耗就会变大。这种模型应用的非常广泛，常见的ASP.NET或者Java编写的网络服务一般都属于这种模型。这类服务可以采用异步I/O的方式来提升服务器性能。不得不提一下C#的异步编程，它提供的一些语法糖写起来就跟写同步代码差不多，简直太傻瓜化、太爽了。事件驱动 事件驱动这四个字不是很好理解。我把它理解为是为了实现异步I/O的一种处理方式：当执行I/O操作时，绑定一个事件，等I/O操作完成会触发这个事件。（I/O操作包括读写数据库，读写文件，网络请求等一些除CPU计算之外的操作）采用这种实现方式的有Node和Nginx，利用单线程来避免高并发下内存开销大和上下文切换频繁的问题。不过它是如何利用单线程就能处理大量的请求呢？以Node为例来解释一下这个问题。考虑到目前的网络服务处理的大部分请求都是跟I/O操作相关，而且I/O操作在整个响应过程中一般是最耗时的。如果采用以往同步I/O的方式，就会阻塞这个线程，必须等I/O操作完才能执行接下来的任务。Node的特点包括单线程和异步I/O。其实在单线程的条件下，真正并发执行的是I/O操作。每个请求按次序等待该线程的处理，不过由于异步I/O的特点，每个请求进来触发I/O操作，即使I/O操作还没执行完，该线程也能继续处理其他请求。这类服务有个特点就是不处理或者只处理非常少量的CPU计算（这也可以说是它的缺点）。假设有一个极端的场景：每个请求都不需要I/O操作，但是都需要比较耗时的CPU计算。那么这类服务就会表现得跟重复型服务一样，每个请求都会阻塞服务。虽然Node可以为每个耗时的CPU计算创建一个子进程，如果为每个请求都创建一个进程就会表现得跟每请求每进程一样。当然这种场景现实中应该不会出现，举这个例子主要还是为了说明它的特点。Goroutine 这是之前瞎捣鼓Go的时候接触到的东西。Go的出现是为了解决在21世纪多核和网络化环境下越来越复杂的编程问题。可能大部分技术人员对Google都会有迷之信仰，谷歌出品，必属精品。Go的并发模型理论指导来自于贝尔实验室的Tony Hoare于1978年发表的鲜为外界所知的关于并发研究的基础文献顺序通信进程 （communicating sequential processes） ，缩写为CSP。（看来什么事情都是理论先行啊，就如当年的XX主义。）在CSP中，程序是一组中间没有共享状态的平行运行的处理过程，它们之间使用管道进行通信和控制同步。在这样的理论指导下，Go采用Goroutine来实现并行，Goroutine之间通过Channels来通信，而不提倡使用共享数据和锁。我们可以借助线程来理解Goroutine。每个线程都会分配到一定大小的内存（一般为2M）作为线程栈，这个栈用来存储当前正在调用或者被挂起的函数的内部变量。如果采用每请求每线程的服务，可能大部分的请求都用不了多少的栈空间，这就造成内存的浪费。每个Goroutine会分配到一个动态栈，一开始为2KB（应用到网络服务，这可能已经能满足大部分请求所需要的栈空间了）。栈的大小会根据需要动态伸缩，最大可达1GB，虽然一般用不到这么大，但是对于更复杂，更深层次的函数递归调用，可能会需要大一点的栈空间。由于创建Goroutine的成本非常低，所以创建成百上千Goroutine是非常普遍的。利用Goroutine来处理请求，既能保证资源充分利用，又不会因为执行CPU计算而阻塞服务。关键地方在于Go的运行时包含一个调度器（它决定了Goroutine调度的效率）。它采用m:n调度，表示会在n个操作系统线程上调度m个Goroutine。n通过GOMAXPROCS这个变量来决定，默认为CPU核心数。就个人愚见，Go的并发模型真的是非常棒，既能保证资源充分利用，又不会因为执行CPU计算而阻塞服务。事件驱动模型虽然能处理很大的并发请求，但是有其局限性。多线程模型目前的问题主要是同步I/O操作长时间阻塞线程，导致创建大量的线程，如果采用异步I/O的方式相信性能方面会提升很多。">
<meta name="twitter:image" content="https://agchen28.github.io/images/default.png">


<script type="application/ld+json">
  {
    "@context": "http://schema.org",
    "@type": "NewsArticle",
    "mainEntityOfPage": {
      "@type": "WebPage",
      "@id":"https://agchen28.github.io/"
    },
    "headline": "客户-服务器模型 - agchen",
    "image": {
      "@type": "ImageObject",
      "url": "https://agchen28.github.io/images/default.png",
      "height": 800,
      "width": 800
    },
    "datePublished": "2017-02-20T09:55:22JST",
    "dateModified": "2017-02-20T09:55:22JST",
    "author": {
      "@type": "Person",
      "name": "agchen"
    },
    "publisher": {
      "@type": "Organization",
      "name": "agchen",
      "logo": {
        "@type": "ImageObject",
        "url": "https://agchen28.github.io/images/logo.png",
        "width": 600,
        "height": 60
      }
    },
    "description": "大部分网络应用程序在编写时都假设一端是客户，另一端是服务器，其目的是让服务器为客户提供特定服务。
一般将这种服务分为两种类型：重复型或并发型。
 重复型：
重复型服务器通过以下步骤进行交互：
1.等待一个客户请求的到来
2.处理客户请求
3.发送响应给客户
4.返回1步
重复型服务器的主要问题发生在2步，这时候它不能为其他客户提供服务。 这种执行模型是同步的，它同时只能处理一个请求，其他的请求都必须按次序等待服务。
这种服务模型处理能力相当低下，假设处理每个请求消耗的时间为N秒，这类服务的QPS就为1/N。
 并发型：
并发型服务器采用以下步骤：
1.等待一个客户请求的到来
2.启动一个新的服务器来处理客户的请求。可能生成一个新的进程、线程或者任务，并依赖底层操作系统的支持。生成新的服务器对用户的全部请求进行处理，处理结束后终止这个服务器。
3.返回1
  并发型服务器的实现方式 每请求每进程 为每一个请求都单独创建一个进程来作为服务。
这种模型的缺点就是代价非常大，内存占用高，进程的创建与销毁时间开销大，而且每台机器所能创建的进程也非常有限。
每请求每线程 由于创建进程开销过大，所以引入了多线程模型。
线程相对于进程来说开销小很多，而且进程之间的每个线程可以共享数据。
每个线程都有一个独立的线程栈，需要占用一定的内存空间。
当并发量非常大的时候，会同时创建大量的线程，这样内存占用就上来了。而且还会出现另外一个问题，就是CPU上下文频繁切换的开销。 每个CPU核心在同一时刻只能处理一件事，操作系统通过将CPU切分时间片的方法，让线程可以较为均匀地使用CPU资源。当线程数量过多的时候，进行上下文切换的消耗就会变大。
这种模型应用的非常广泛，常见的ASP.NET或者Java编写的网络服务一般都属于这种模型。
这类服务可以采用异步I/O的方式来提升服务器性能。不得不提一下C#的异步编程，它提供的一些语法糖写起来就跟写同步代码差不多，简直太傻瓜化、太爽了。
事件驱动 事件驱动这四个字不是很好理解。我把它理解为是为了实现异步I/O的一种处理方式：当执行I/O操作时，绑定一个事件，等I/O操作完成会触发这个事件。（I/O操作包括读写数据库，读写文件，网络请求等一些除CPU计算之外的操作）
采用这种实现方式的有Node和Nginx，利用单线程来避免高并发下内存开销大和上下文切换频繁的问题。
不过它是如何利用单线程就能处理大量的请求呢？
以Node为例来解释一下这个问题。
考虑到目前的网络服务处理的大部分请求都是跟I/O操作相关，而且I/O操作在整个响应过程中一般是最耗时的。如果采用以往同步I/O的方式，就会阻塞这个线程，必须等I/O操作完才能执行接下来的任务。
Node的特点包括单线程和异步I/O。其实在单线程的条件下，真正并发执行的是I/O操作。每个请求按次序等待该线程的处理，不过由于异步I/O的特点，每个请求进来触发I/O操作，即使I/O操作还没执行完，该线程也能继续处理其他请求。
这类服务有个特点就是不处理或者只处理非常少量的CPU计算（这也可以说是它的缺点）。
假设有一个极端的场景：每个请求都不需要I/O操作，但是都需要比较耗时的CPU计算。那么这类服务就会表现得跟重复型服务一样，每个请求都会阻塞服务。虽然Node可以为每个耗时的CPU计算创建一个子进程，如果为每个请求都创建一个进程就会表现得跟每请求每进程一样。当然这种场景现实中应该不会出现，举这个例子主要还是为了说明它的特点。
Goroutine 这是之前瞎捣鼓Go的时候接触到的东西。
Go的出现是为了解决在21世纪多核和网络化环境下越来越复杂的编程问题。
可能大部分技术人员对Google都会有迷之信仰，谷歌出品，必属精品。
Go的并发模型理论指导来自于贝尔实验室的Tony Hoare于1978年发表的鲜为外界所知的关于并发研究的基础文献顺序通信进程 （communicating sequential processes） ，缩写为CSP。（看来什么事情都是理论先行啊，就如当年的XX主义。）
在CSP中，程序是一组中间没有共享状态的平行运行的处理过程，它们之间使用管道进行通信和控制同步。在这样的理论指导下，Go采用Goroutine来实现并行，Goroutine之间通过Channels来通信，而不提倡使用共享数据和锁。
我们可以借助线程来理解Goroutine。
每个线程都会分配到一定大小的内存（一般为2M）作为线程栈，这个栈用来存储当前正在调用或者被挂起的函数的内部变量。如果采用每请求每线程的服务，可能大部分的请求都用不了多少的栈空间，这就造成内存的浪费。
每个Goroutine会分配到一个动态栈，一开始为2KB（应用到网络服务，这可能已经能满足大部分请求所需要的栈空间了）。栈的大小会根据需要动态伸缩，最大可达1GB，虽然一般用不到这么大，但是对于更复杂，更深层次的函数递归调用，可能会需要大一点的栈空间。
由于创建Goroutine的成本非常低，所以创建成百上千Goroutine是非常普遍的。利用Goroutine来处理请求，既能保证资源充分利用，又不会因为执行CPU计算而阻塞服务。
关键地方在于Go的运行时包含一个调度器（它决定了Goroutine调度的效率）。它采用m:n调度，表示会在n个操作系统线程上调度m个Goroutine。n通过GOMAXPROCS这个变量来决定，默认为CPU核心数。
就个人愚见，Go的并发模型真的是非常棒，既能保证资源充分利用，又不会因为执行CPU计算而阻塞服务。事件驱动模型虽然能处理很大的并发请求，但是有其局限性。多线程模型目前的问题主要是同步I/O操作长时间阻塞线程，导致创建大量的线程，如果采用异步I/O的方式相信性能方面会提升很多。"
  }
</script>


    <link href="https://agchen28.github.io/css/styles.css" rel="stylesheet">
  </head>

  <body>
    
    
    

    <header class="l-header">
      <nav class="navbar navbar-default">
        <div class="container">
          <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
              <span class="sr-only">Toggle navigation</span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
            </button>
            
          </div>

          
          <div id="navbar" class="collapse navbar-collapse">
            
            <ul class="nav navbar-nav navbar-right">
              
              
              <li><a href="/">首页</a></li>
              
              
              
              <li><a href="/categories/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/">技术相关</a></li>
              
              
              
              <li><a href="/categories/%E6%8D%A1%E5%9E%83%E5%9C%BE/">捡垃圾</a></li>
              
              
              
              <li><a href="/about">关于</a></li>
              
              
            </ul>
            
          </div>
          

        </div>
      </nav>
    </header>

    <main>
      <div class="container">
        
<div class="row">
  <div class="col-md-8">

    <nav class="p-crumb">
      <ol class="breadcrumb">
        <li><a href="https://agchen28.github.io/"><i class="fa fa-home" aria-hidden="true"></i></a></li>
        
        <li class="active">客户-服务器模型</li>
      </ol>
    </nav>

    <article class="single">
  <header>
    <ul class="p-facts">
      <li><i class="fa fa-calendar" aria-hidden="true"></i><time datetime="2017-02-20T09:55:22JST">2017年02月20日</time></li>
      
      
    </ul>

    <h1 class="title">客户-服务器模型</h1>
  </header>

  

  <div class="article-body">

<p>大部分网络应用程序在编写时都假设一端是客户，另一端是服务器，其目的是让服务器为客户提供特定服务。<br />
一般将这种服务分为两种类型：重复型或并发型。</p>

<ul>
<li><p>重复型：<br />
重复型服务器通过以下步骤进行交互：<br />
1.等待一个客户请求的到来<br />
2.处理客户请求<br />
3.发送响应给客户<br />
4.返回1步<br />
重复型服务器的主要问题发生在2步，这时候它不能为其他客户提供服务。
这种执行模型是同步的，它同时只能处理一个请求，其他的请求都必须按次序等待服务。<br />
这种服务模型处理能力相当低下，假设处理每个请求消耗的时间为N秒，这类服务的QPS就为1/N。</p></li>

<li><p>并发型：<br />
并发型服务器采用以下步骤：<br />
1.等待一个客户请求的到来<br />
2.启动一个新的服务器来处理客户的请求。可能生成一个新的进程、线程或者任务，并依赖底层操作系统的支持。生成新的服务器对用户的全部请求进行处理，处理结束后终止这个服务器。<br />
3.返回1</p></li>
</ul>

<h2 id="并发型服务器的实现方式">并发型服务器的实现方式</h2>

<h3 id="每请求每进程">每请求每进程</h3>

<p>为每一个请求都单独创建一个进程来作为服务。<br />
这种模型的缺点就是代价非常大，内存占用高，进程的创建与销毁时间开销大，而且每台机器所能创建的进程也非常有限。</p>

<h3 id="每请求每线程">每请求每线程</h3>

<p>由于创建进程开销过大，所以引入了多线程模型。<br />
线程相对于进程来说开销小很多，而且进程之间的每个线程可以共享数据。<br />
每个线程都有一个独立的线程栈，需要占用一定的内存空间。<br />
当并发量非常大的时候，会同时创建大量的线程，这样内存占用就上来了。而且还会出现另外一个问题，就是CPU上下文频繁切换的开销。
每个CPU核心在同一时刻只能处理一件事，操作系统通过将CPU切分时间片的方法，让线程可以较为均匀地使用CPU资源。当线程数量过多的时候，进行上下文切换的消耗就会变大。<br />
这种模型应用的非常广泛，常见的ASP.NET或者Java编写的网络服务一般都属于这种模型。<br />
这类服务可以采用异步I/O的方式来提升服务器性能。不得不提一下C#的异步编程，它提供的一些语法糖写起来就跟写同步代码差不多，简直太傻瓜化、太爽了。</p>

<h3 id="事件驱动">事件驱动</h3>

<p>事件驱动这四个字不是很好理解。我把它理解为是为了实现异步I/O的一种处理方式：当执行I/O操作时，绑定一个事件，等I/O操作完成会触发这个事件。（I/O操作包括读写数据库，读写文件，网络请求等一些除CPU计算之外的操作）<br />
采用这种实现方式的有Node和Nginx，利用单线程来避免高并发下内存开销大和上下文切换频繁的问题。<br />
不过它是如何利用单线程就能处理大量的请求呢？<br />
以Node为例来解释一下这个问题。<br />
考虑到目前的网络服务处理的大部分请求都是跟I/O操作相关，而且I/O操作在整个响应过程中一般是最耗时的。如果采用以往同步I/O的方式，就会阻塞这个线程，必须等I/O操作完才能执行接下来的任务。<br />
Node的特点包括单线程和异步I/O。其实在单线程的条件下，真正并发执行的是I/O操作。每个请求按次序等待该线程的处理，不过由于异步I/O的特点，每个请求进来触发I/O操作，即使I/O操作还没执行完，该线程也能继续处理其他请求。<br />
这类服务有个特点就是不处理或者只处理非常少量的CPU计算（这也可以说是它的缺点）。<br />
假设有一个极端的场景：每个请求都不需要I/O操作，但是都需要比较耗时的CPU计算。那么这类服务就会表现得跟重复型服务一样，每个请求都会阻塞服务。虽然Node可以为每个耗时的CPU计算创建一个子进程，如果为每个请求都创建一个进程就会表现得跟每请求每进程一样。当然这种场景现实中应该不会出现，举这个例子主要还是为了说明它的特点。</p>

<h3 id="goroutine">Goroutine</h3>

<p>这是之前瞎捣鼓Go的时候接触到的东西。<br />
Go的出现是为了解决在21世纪多核和网络化环境下越来越复杂的编程问题。<br />
可能大部分技术人员对Google都会有迷之信仰，谷歌出品，必属精品。<br />
Go的并发模型理论指导来自于贝尔实验室的Tony Hoare于1978年发表的鲜为外界所知的关于并发研究的基础文献顺序通信进程 （communicating sequential processes） ，缩写为CSP。（看来什么事情都是理论先行啊，就如当年的XX主义。）<br />
在CSP中，程序是一组中间没有共享状态的平行运行的处理过程，它们之间使用管道进行通信和控制同步。在这样的理论指导下，Go采用Goroutine来实现并行，Goroutine之间通过Channels来通信，而不提倡使用共享数据和锁。<br />
我们可以借助线程来理解Goroutine。<br />
每个线程都会分配到一定大小的内存（一般为2M）作为线程栈，这个栈用来存储当前正在调用或者被挂起的函数的内部变量。如果采用每请求每线程的服务，可能大部分的请求都用不了多少的栈空间，这就造成内存的浪费。<br />
每个Goroutine会分配到一个动态栈，一开始为2KB（应用到网络服务，这可能已经能满足大部分请求所需要的栈空间了）。栈的大小会根据需要动态伸缩，最大可达1GB，虽然一般用不到这么大，但是对于更复杂，更深层次的函数递归调用，可能会需要大一点的栈空间。<br />
由于创建Goroutine的成本非常低，所以创建成百上千Goroutine是非常普遍的。利用Goroutine来处理请求，既能保证资源充分利用，又不会因为执行CPU计算而阻塞服务。<br />
关键地方在于Go的运行时包含一个调度器（它决定了Goroutine调度的效率）。它采用m:n调度，表示会在n个操作系统线程上调度m个Goroutine。n通过GOMAXPROCS这个变量来决定，默认为CPU核心数。</p>

<p>就个人愚见，Go的并发模型真的是非常棒，既能保证资源充分利用，又不会因为执行CPU计算而阻塞服务。事件驱动模型虽然能处理很大的并发请求，但是有其局限性。多线程模型目前的问题主要是同步I/O操作长时间阻塞线程，导致创建大量的线程，如果采用异步I/O的方式相信性能方面会提升很多。</p>
</div>

  

</article>


    
  </div>

  <div class="col-md-4">
    
<aside class="l-sidebar">

  
  
  
  
  <section class="panel panel-default">
    <div class="panel-heading">
      <div class="panel-title">TAG</div>
    </div>
    <div class="list-group">
      
      <a href="https://agchen28.github.io/tags/dotnet" class="list-group-item">dotnet</a>
      
      <a href="https://agchen28.github.io/tags/%E5%A4%87%E5%BF%98" class="list-group-item">备忘</a>
      
      <a href="https://agchen28.github.io/tags/java" class="list-group-item">java</a>
      
      <a href="https://agchen28.github.io/tags/javascript" class="list-group-item">javascript</a>
      
      <a href="https://agchen28.github.io/tags/storm" class="list-group-item">storm</a>
      
      <a href="https://agchen28.github.io/tags/%E6%8D%A1%E5%9E%83%E5%9C%BE" class="list-group-item">捡垃圾</a>
      
      <a href="https://agchen28.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F" class="list-group-item">设计模式</a>
      
      <a href="https://agchen28.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0" class="list-group-item">读书笔记</a>
      
    </div>
  </section>
  
  

  
  <section class="panel panel-default">
    <div class="panel-heading">
      <div class="panel-title">LATESTS</div>
    </div>
    <div class="list-group">
      
      <a href="https://agchen28.github.io/blog/%E6%B3%9B%E5%9E%8B/" class="list-group-item">泛型</a>
      
      <a href="https://agchen28.github.io/blog/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/" class="list-group-item">单例模式</a>
      
      <a href="https://agchen28.github.io/blog/javascript%E4%B8%AD%E7%9A%84function/" class="list-group-item">JavaScript中的function</a>
      
      <a href="https://agchen28.github.io/blog/.net%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/" class="list-group-item">.NET程序执行过程</a>
      
      <a href="https://agchen28.github.io/blog/javascript%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1/" class="list-group-item">JavaScript中的对象</a>
      
      <a href="https://agchen28.github.io/blog/%E5%AE%A2%E6%88%B7-%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A8%A1%E5%9E%8B/" class="list-group-item">客户-服务器模型</a>
      
      <a href="https://agchen28.github.io/blog/storm%E4%B8%ADtopology%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/" class="list-group-item">Storm中Topology的执行过程</a>
      
      <a href="https://agchen28.github.io/blog/mongodb%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95/" class="list-group-item">Mongodb安装记录</a>
      
      <a href="https://agchen28.github.io/blog/redis%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95/" class="list-group-item">Redis安装记录</a>
      
      <a href="https://agchen28.github.io/blog/storm%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/" class="list-group-item">Storm集群搭建</a>
      
    </div>
  </section>
  

</aside>


  </div>
</div>

      </div>
    </main>

    <footer class="l-footer">
      <div class="container">
        <p><span class="h-logo">&copy; agchen</span></p>
        <aside>
          <p>Powered by <a href="https://gohugo.io/">Hugo</a>.</p>
          <p><a href="https://github.com/dim0627/hugo_theme_beg">Beg</a> designed by <a href="http://yet.unresolved.xyz/">Daisuke Tsuji</a>.</p>
        </aside>
      </div>
    </footer>

    <script src="//code.jquery.com/jquery-3.1.1.min.js"></script>
    <script src="//maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
  </body>
</html>

